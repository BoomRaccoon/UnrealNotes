\documentclass{scrbook}
%\usepackage{showframe}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage{lmodern}
\usepackage[ngerman, english]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[colorlinks]{hyperref}
\hypersetup{
    colorlinks = true,
    linkcolor = green,
    urlcolor = blue
}

\usepackage[backend=biber]{biblatex}
\usepackage[xindy, toc, nonumberlist]{glossaries}
\usepackage{float}
\usepackage{enumitem}
\usepackage{tabularray}
\usepackage{makecell}
\usepackage{ulem}
\usepackage{arydshln}
\usepackage{mathabx}
\setlist{nosep}
\usepackage{graphicx}
\graphicspath{{Bilder/}}	 % pfad zum Verzeichnis das die Bilder enthält
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{tcolorbox}
\usepackage{multicol}
\usepackage{csquotes}
\usepackage{lscape}
\usepackage{pdfcomment}
\usepackage[includeheadfoot]{geometry}
\geometry
{
    top=10mm,
    left=10mm,
    right=5mm,
}
\author{}
\newcommand{\code}[1]{\colorbox{mygray}{\lstinline|#1|}}

\usepackage{fancyhdr}
\pagestyle{fancy}


\loadglsentries{/Gdrive/Glossaries/CG_Glossary.tex}

\makeglossaries
\definecolor{mygray}{rgb}{0.8,0.8,0.8}
\lstset{
    backgroundcolor=\color{mygray},
    basicstyle=\ttfamily,
    columns=fullflexible,
    frame=single,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
}
\title{Learning Unreal}
    
\begin{document}
\include{Glossar}
\maketitle
{
  \hypersetup{linkcolor=black}
  \tableofcontents
}

    \chapter{General}
        \section{Notes}
        \begin{itemize}
            \item CTRL+[{1,2, ... 9}] places a camera at the current viewport position to jump to them with {1,2, ... 9}
            \item TSubclassOf<[CLASSNAME]> [NAME];
            \item EV (Exposure-Value) can be set in: View Mode
            \begin{itemize}
                \item Home/Interior: 5-7
                \item Office: 7/8
                \item Outdoor: 15
            \end{itemize}
            \item \code{OnPossess} is executed before \code{OnBeginPlay}
            \item \code{GetOuterByClass} to find specific parent
            \item don't bind to delegates from constructor
            \item \code{inline} basically tells the compiler/linker that the function can be defined in multiple translation units, in the end it chooses one of them
            \item a looped montage will still stop if it’s Enable auto blend out is checked
        \end{itemize}

        \uline{template for a .GITIGNORE file}
        \begin{lstlisting}
    # Visual Studio 2015 user specific files
    .vs/
    
    # Compiled Object files
    *.slo
    *.lo
    *.o
    *.obj
    
    # Precompiled Headers
    *.gch
    *.pch
    
    # Compiled Dynamic libraries
    *.so
    *.dylib
    *.dll
    
    # Fortran module files
    *.mod
    
    # Compiled Static libraries
    *.lai
    *.la
    *.a
    *.lib
    
    # Executables
    *.exe
    *.out
    *.app
    *.ipa
    
    # These project files can be generated by the engine
    *.xcodeproj
    *.xcworkspace
    *.sln
    *.suo
    *.opensdf
    *.sdf
    *.VC.db
    *.VC.opendb
    
    # Precompiled Assets
    SourceArt/**/*.png
    SourceArt/**/*.tga
    
    # Builds
    Build/*
    
    # Whitelist PakBlacklist-<BuildConfiguration>.txt files
    !Build/*/
    Build/*/**
    !Build/*/PakBlacklist*.txt
    
    # Don't ignore icon files in Build
    !Build/**/*.ico
    
    
    # Configuration files generated by the Editor
    Saved/*
    
    # Compiled source files for the engine to use
    Intermediate/*
    
    #Binaries
    Binaries/*
    .idea/*
    Plugins/*
    
    # Cache files for the editor to use
    DerivedDataCache/*
    
    Platforms/*
        \end{lstlisting}

        \uline{Window-Resize}
        \includegraphics[width=\textwidth]{WindowResize.jpg}




        \section{Game Engine Concepts}
            \begin{itemize}
                \item \href{https://docs.unrealengine.com/5.1/en-US/actor-ticking-in-unreal-engine/https://docs.unrealengine.com/5.1/en-US/actor-ticking-in-unreal-engine/}{Official Docs}
                \item Tick-groups:
                \begin{itemize}
                    \item TG\_PrePhysics :
                            This is the tick group to use if your actor is intended to interact with physics objects, including physics-based attachments. This way, the actor's movement is complete and can be factored into physics simulation.
                            Physics simulation data during this tick will be one frame old - i.e. the data that was rendered to the screen last frame. 
                    \item TG\_DuringPhysics
                            Since this runs at the same time as physics simulation, it is unknown whether physics data during this tick is from the previous frame or the current frame. Physics simulation can finish at any time during this tick group and will not present any information to indicate this fact.
                            Because physics simulation data could be current or one frame out of date, this tick group is recommended only for logic that doesn't care about physics data or that can afford to be one frame off. Common cases might be updating inventory screens or minimap displays, where physics data is either entirely irrelevant, or displayed coarsely enough that the potential to have a single frame of lag does not matter.
                    \item TG\_PostPhysics
                            Results from this frame's physics simulation are complete by the time this tick group runs.
                            A good use of this group might be for weapon or movement traces, so that all physics objects are known to be in their final positions, as they will be when this frame is rendered. This is especially useful for things like laser sights in shooting games, where the laser beam must appear to come from the player's gun at its final position, and even a single frame of lag will be very noticeable. 
                    \item TG\_PostUpdateWork
                            This runs after TG\_PostPhysics. Historically, its primary function has been to feed last-possible-moment information into particle systems.
                \end{itemize}
            \end{itemize}

        \section{Config files}

            \begin{itemize}
                \item example config variable: \code{[Core.Log]LogTemp=warning}
                \item \code{SECTION}
                \begin{itemize}
                    \item alphabetic strings
                    \item sections for configurable objects contained in modules use the syntex \\
                    Modules: \code{[/Script/ModuleName.ClassName]} \\
                    Plugins: \code{[[/Script/PluginName.ClassName]]} \\
                    Blueprints: \code{[/PathToUAsset/UAssetName.UAssetName_C]} \\

                \end{itemize}
                \item \code{KEY}
                \begin{itemize}
                    \item belong to a \code{[SECTION]}
                    \item have a \code{KEY} and a \code{VALUE}
                    \item the \code{KEY} is always a string
                    \item the \code{VALUE} can be a string, number, boolean, array, struct or empty
                \end{itemize}
                \item \code{Comments}: are made using \code{;}
            \end{itemize}
            For more information about the configuration file hierarchy, see the header file \code{ConfigHierarchy.h} located in \code{Engine/Source/Runtime/Core/Public/Misc}

            GConfig is a global object that can be used to read and write configuration files. It is a member of the FConfigCacheIni class \\
            \begin{table}[!htb]
                \begin{tblr}{p{6cm}}
                    \hline
                        Access specifier \\
                    \hline
                        GetBool  \\
                        GetInt  \\
                        GetInt64  \\
                        GetFloat  \\
                        GetDouble  \\
                        GetArray  \\
                        GetString  \\
                        GetText  \\
                    \hline
                \end{tblr}
            \caption{ \code{GConfig->} functions }  
            \end{table}

            \begin{table}[!htb]
                \begin{tblr}{p{6cm}}
                    \hline
                        Category \\
                    \hline
                        GEditorIni \\
                        GEditorKeyBindingsIni \\
                        GEditorSettingsIni \\
                        GEditorIni \\
                        GEditorPerProjectIni \\
                        GCompatIni \\
                        GLightMassIni \\
                        GScalabilityIni \\
                        GHardwareIni \\
                        GInputIni \\
                        GGameIni \\
                        GGameUserSettingsIni \\
                        GRuntimeOptionsIni \\
                        GInstallBundleIni \\
                        GDeviceProfilesIni \\
                        GGameplayTagsIni \\
                        GNearClippingPlaneIni \\
                        GNearClippingPlaneIni\_RenderThread \\
                    \hline
                \end{tblr} 
            \caption{ Ini Categories }  
            \end{table}
            
            

Structure:
\begin{lstlisting}
[SECTION1]
<KEY1>=<VALUE1>
<KEY2>=<VALUE2>
    
[SECTION2]
<KEY3>=<VALUE3>
\end{lstlisting}
Example:
\begin{lstlisting}
// your actual class
    UCLASS(config=Game)
class AMyConfigActor : public UObject
{
    GENERATED_BODY()
    
    UPROPERTY(Config)
    int32 MyConfigVariable;
}
\end{lstlisting}
\begin{lstlisting}
// the config file (whatever category you chose)
[MyCategoryName]
MyConfigVariable=2
\end{lstlisting}

Loading value manually
\begin{lstlisting}
int MyConfigVariable;
GConfig->GetInt(TEXT("MyCategoryName"), TEXT("MyVariable"), MyConfigVariable, GGameIni);
\end{lstlisting}


        \section{Migrate}
            \begin{itemize}
                \item things that probably need to be changed in \code{DefaultEngine.ini}:
                \begin{itemize}
                    \item \code{ActiveGameNameRedirects} MUST be used $\rightarrow$ BPs will automatically fix error
                    \item 
                    \item \uline{optional}
                    \item \code{GameViewportClassName} if using CUI
                    \item \code{GameUserSettingsClassName} if using custom GameSettingsClass
                    \item \code{LocalPlayerClassName} if using custom LocalPlayerClass
                \end{itemize}
            \end{itemize}
        \begin{lstlisting}
    +ActiveGameNameRedirects=(OldGameName="/Script/TakingCharge",NewGameName="/Script/LearnTheBasics")

    GameViewportClientClassName=/Script/CommonUI.CommonGameViewportClient
    GameUserSettingsClassName=/Script/TakingCharge.UserSettings_TC
    LocalPlayerClassName=/Script/TakingCharge.LocalPlayer_TC
        \end{lstlisting}    
        
        \section{Unsorted}
        \begin{itemize}
            \item Is mixed in real time and precomputed
            \item scalability: adjusting the quality in runtime
            \item 
            \item Deferred rendering(unreal): 
            \item Forward rendering: 
            \item GBuffer(used by deferred renderer): stores the different images (reflection, roughness, normal ...) that will be mixed together to make the image that will be displayed on the screen
            \item Pixel Shader: most used shaders making per pixel calculations
            \item Vertex Shader: converts local location to world location; using Vertex-Color-Maps to offset object or tell what should be effected in simulations; only for visual effects
            \item materials are more expensive than triangles
            \item dynamic shadows: polycount
            \item Geometry rendering: Project settings->Rendering->
            \item Merge meshes that are used a lot (windows statistics actors count) and afterwards combine materials or far away actors (VR or mobile)
            \item Export selected to further tweak it
            \item Instanced Rendering must be setup at least 50 objects
            \item LOD steps .5 vertex count
            \item HLOD to group outdoor environments
            \item 
            \item Same static mesh with differnet distance culling (better effect while still mentaining performance Optimisation)
            \item 
        \end{itemize}
\bigskip        
        Drawcalls:
        \begin{itemize}
            \item 1000: Mobile
            \item 2000-3000: Good
            \item 5000: OK
            \item >5000: problematic
            \item >10000: most likely unplayable
        \end{itemize}
\bigskip


        \subsection{Redirectors}
            \begin{itemize}
                \item Changes go in an ini file under Config.
                \item Must be in a section called [CoreRedirects]
                \item Usually Config/DefaultEngine.ini
                \item You use the “fully qualified name” of the class ONLY in NewName and not OldName.
                \item 
                \item BP-related-errors might occur $\rightarrow$ resave the BPs
            \end{itemize}
\uline{Example (assuming you moved a class called MyCppClass from MyGameModule to MyNewModule):}
\begin{lstlisting}
[CoreRedirects]
; ... other redirects
+ClassRedirects=(OldName=\"MyCppClass\",NewName=\"/Script/MyNewModule.MyCppClass\")

    //For UObject derived classes you omit the actor A or object U prefix
    //So if we have AMyActor in MyGameModule and we move it to MyCoreModule then the line is

+ClassRedirects=(OldName=\"MyActor\",NewName=\"/Script/MyCoreModule.MyActor\")

    //For struct and enum types we include the FULL name of the class including any prefixes and they also have a different redirect key:
+StructRedirects=(OldName="FMyStruct",NewName="/Script/MyCoreModule.FMyStruct")
+EnumRedirects=(OldName="EMyEnum",NewName="/Script/MyCoreModule.EMyEnum")
\end{lstlisting}

        \section{Before Rendering}
            Performed in order
            \begin{itemize}
                \item Distance Culling: needs setup; removes any object that is further away then [NUMBER] (cull distance volume)
                \item Frustim Culling: always active; removes any object outside of the view
                \item Precomputed Visibility: needs setup(world settings); (precomputed visibility volume)(needs rebuild light)('show'->'visualize'->'precomputed visibility cells'); 
                \item Occlusion Culling: big things rnder most of the time
            \end{itemize}
            CONCLUSION: sublevels will increase performance because culling calculations don't have to be calculated

            
            \subsection{Rasterization}
                Is the conversion of 3D-Objects into pixels \\
                Seeing only 1 pixel of an object does not reduce the calculations to display on it $\rightarrow$ LOD \\
                \includegraphics[width=\textwidth]{Rasterizing.png} \\
                \includegraphics[width=\textwidth]{Overshading.png} \\
                Shading happens in 2x2 Pixels $\rightarrow$ 
                'Optimisation Viewmodes' $\rightarrow$ 'Quad Overdraw'  (transparent object will go above 4; important for forward rendering)\\
                Custom Depth \\


    \chapter{Engine Concepts}
        \begin{itemize}
            \item Everything built with the UnrealBuildTool
            \item Each target compiled from C++ modules
            \item modules use ohter modules by referencing them in their build rules (build.cs file)
            \item 
            \item the UBT will parse the file, look for macros like UCLASS or UPROPERTY and generate code which will be included (thus the include of [ModuleName].generated.h)
            \item Simple Function: can be declared 'FORCEINLINE' in the header to insert the actual code at the place it's called instead of actually calling it
        \end{itemize}

        \section{UObjects / UClass}
            \begin{itemize}
                \item UClass: 
                \begin{itemize}
                    \item is associated to a default instance of the associated UObject class called the Class Default Object (CDO)
                    \item CDO is allocated first and then constructed, only once, via the class constructor when the engine is initialised
                    \item The CDO acts as a template from which all other instances of the class are copied, and the constructor is never called again
                    \item $\rightarrow$ class constructors cannot contain any runtime logic
                \end{itemize} 
            \end{itemize}

        \section{Actors}
            \subsection{Reflections}
                \begin{itemize}
                    \item reflection capture actors: are static reflection actors (quality can be adjusted in project settings under 'reflection resolution')
                    \item screenspace reflections are post render reflections with a medium resource cost
                    \item planar reflections must be eneabled (support global clip plane), are very expensive but are full dynamic  
                \end{itemize}

            \section{Creation}
            \href{https://docs.unrealengine.com/5.0/en-US/unreal-engine-actor-lifecycle/}{offic. docs}
                \begin{table}[!htb]
                    \begin{tblr}{p{6cm} | p{12cm}}
                        \hline
                            Method & Description \\
                        \hline
                            UObject::PostLoad & for statically placed actors in a level; called in edtiro \& gameplay \\
                            UActorComponent::OnComponentCreated &
                            when actor is spawned; \\
                            AACtor::PreRegisterAllComponents &
                            statically \& spawned actors htat have native root components \\
                            UActorComponent::RegisterComponent &
                            creaets the physical representation of the components \\
                            AActorPostRegisterAllComponents & 
                            last functino that gets called for all actors \\
                            AActor::PostActorCreated &
                            called right before construction \\
                            AActor::PreInitializeComponents &
                            only during gameplay and certain editor preview windows \\
                            UActorComponent::InitializeComponents &
                            if \code{bWantsInizializeComponetSet} is true; only once per gameplay session \\
                            AActor::PostInitializeComponents &
                            after the actor's components ahve beeen initialized; during gameplay \\
                        \hline
                    \end{tblr}
                \end{table}
                \begin{figure}
                    \includegraphics[width=\textwidth, height=\textheight]{ActorLifeCycle.png}
                    \caption{Lifecycle}
                \end{figure}
                

        \section{Project Structure}
        \underline{In File-Explorer:}
        \begin{itemize}
            \item Binaries: compiled game libraries \& debug database
            \item config: default configureation file
            \item Content: contains the assets
            \item intermediate: temporary files (can be safely deleted)
            \item Saved: configuration files created at runtime (also log files)
            \item 
            \item $[$ ProjectName $]$.project: JSON-file containing the information of the project (to display in the launcher)
        \end{itemize}

        \section{Gameplay Framework}
             \begin{figure}[ht]
                \includegraphics[width=\textwidth]{GameFramework.jpg}
                \caption{This flowchart illustrates how these core gameplay classes relate to each other.
                A game is made up of a GameMode and GameState. Human players joining the game are associated
                with PlayerControllers. These PlayerControllers allow players to possess pawns in the game
                so they can have physical representations in the level. PlayerControllers also give players
                input controls, a heads-up display, or HUD, and a PlayerCameraManager for handling camera views. }
             \end{figure}

            \subsection{Pawn}
                \begin{itemize}
                    \item is an Actor that can be an agent wihthin the world
                    \item can be possessed by Controllers
                    \item accept input
                \end{itemize}
            \subsection{Character}
                \begin{itemize}
                    \item humanoid Pawn
                    \item contains
                    \begin{itemize}
                        \item CapsuleComponent
                        \item CharacterMovementComponent
                    \end{itemize}
                    \item can replicate movement smoothly across the network
                \end{itemize}
            \subsection{Controller}
                \begin{itemize}
                    \item Base-Actor-Class that is responsible for directing a Pawn
                \end{itemize}
            \subsection{PlayerController}
                \begin{itemize}
                    \item interface between the Pawn and human player controlling it
                    \item has
                    \begin{itemize}
                        \item \code{PlayerCameraManager}
                        \item \code{PlayerInput}
                    \end{itemize} 
                    \item 
                \end{itemize}
            \subsection{AIController}
                \begin{itemize}
                    \item 
                \end{itemize}
            \subsection{HUD}
                \begin{itemize}
                    \item is used to displayed information to the player 
                    \item 
                \end{itemize}
            \subsection{Camera}
                \begin{itemize}
                    \item 
                \end{itemize}
            \subsection{GameMode}
                \begin{itemize}
                    \item on server
                    \item always 1 present
                    \item contains information/rules like:
                    \begin{itemize}
                        \item number of present\&maximum player and spectators
                        \item how players enter the game e.g. spawn locations and spawn behavior
                        \item how pausing is handled
                        \item level transitions
                    \end{itemize}
                    \item AGameModeBase: Is the new simpler and more efficient class from which every other game mode is dervied
                    \item AGameMode: is a complex class with additional features and a child of AGameModeBase
                \end{itemize}
                
                \underline{functionality}
                \begin{table}[H]
                    \begin{tabular}{|p{6cm}|p{12cm}|}
                        \hline
                            Function/Event & Purpose \\
                        \hline
                            InitGame (E) & Is fired before any other script. Initializes parameters and spawns helper classes \\
                            PreLogin (F) & Is called before the Login and will not call Login if ErrorMessage is set \\
                            PostLogin (F) & Is called after Login and the first place to call replicated functions safely \\
                            Logout & Called when player leaves a game or is destroyed implementation via 'OnLogout'-Event \\
                            HandleStatingNewPlayer & Called after PostLogin or after seamless travel \\
                            RestartPlayer & called when spawning a player \\
                            RestartPlayerAtPlayerStart &  \\
                            RestartPlayerAtTransform &  \\
                            SpawnDefaultPawnAtTransform &  \\
                        \hline
                    \end{tabular}
                \end{table}

            \subsection{GameState}
                \begin{itemize}
                    \item on Server \& Client
                    \item Saved on Server REPLICATED to client
                    \item handles information about the game that everonye should know about (scores, quests, ) 
                    \item not specific to any player $\rightarrow$ game-wide-properties
                \end{itemize}
            \subsection{PlayerState}
                \begin{itemize}
                    \item on Server \& Server
                    \item contains Player-specific-data (name, score, in-match-level)
                \end{itemize}
        \section{Game Flow}
            \begin{figure}[ht]
                \includegraphics[width=\textwidth]{GameFlow.jpg}
                \caption{}
            \end{figure}

            \begin{itemize}
                \item init engine
                \item init \code{GameInstance}
                \item load level
                \item start playing
            \end{itemize}

    \chapter{Core engine classes}

        \section{UEngine}
            

        \section{Customize core engine classes}
            \begin{figure}
                \includegraphics[]{EngineCustomization.png}
                \caption{Customizable engine classes}
                \label{}
            \end{figure}
        
            \begin{itemize}
                \item go into \code{DefaultEngine.ini}
                \item under \code{[/Script/Engine.Engine]} set for example:
                \begin{itemize}
                    \item \code{GameViewportClientClassName=/Script/CommonUI.CommonGameViewportClient}
                    \item \code{GameUserSettingsClassName=/Script/TakingCharge.GameUserSettings_TC}
                    \item \code{LocalPlayerClassName=/Script/TakingCharge.LocalPlayer_TC}
                \end{itemize}
            \end{itemize}

    \chapter{Configuration files}
        \section{Config/DefaultEngine.ini}
            \begin{itemize}
                \item Contains:
                \begin{itemize}
                    \item Default starting map (Game+Editor)
                    \item Default GameMode
                \end{itemize}
            \end{itemize}

        \section{Config/DefaultGame.ini}
            \begin{itemize}
                \item Contains:
                \begin{itemize}
                    \item \code{PrimaryAssets} to scan
                \end{itemize}
            \end{itemize}

    \chapter{Input Processing (Gameplay)}
        UI has it's own input processing and comes before gameplay (\hyperlink{input:UI}{UI input processing})\\
        \section{Basics}
            \begin{itemize}
                \item \code{UInputComponent} := an \code{UActorComponent} enables actor to bind input events to delegate functions
                \item \code{PlayerController} := manages a stack of InputComponents
                \item \code{UPlayerInput} := processess input
                \item \code{IEnhancedInputSubsystemInterface} := useful functions for enhanced input
                \item \code{UEnhancedInputLocalPlayerSubsystem} := 
            \end{itemize}

        \section{PlayerInput}
        \begin{itemize}
            \item \code{PlayerInput} is inside the \code{PlayerController}
            \item processess player input
            \item only on client
            \item 
            \item \code{PlayerInput} contained structures are:
            \begin{itemize}
                \item \code{FInputActionKeyMapping}: binds a key press to an event-driven behavior
                \item \code{FInputAcisKeyMapping}: binds a key, so it is continuously polled
            \end{itemize}
        \end{itemize}
            \subsection{EnhancedPlayerInput}
                \begin{itemize}
                    \item derives from \code{PlayerInput}
                    \item 
                \end{itemize}
        
        \section{InputComponent}
            \begin{itemize}
                \item \code{InputComponent} is commonly inside \code{Pawn} or \code{Controller}
                \item links the \code{Mappings} to \code{Game-Actions}
                \item input will be handle in the following order:
                \begin{itemize}
                    \item 1. Actor with 'Accepts input' from most recently enabled
                    \item 2. Controllers
                    \item 3. Level Script
                    \item 4. Pawns
                \end{itemize}
                \item if one component takes the input, it is not available down the stack
            \end{itemize}

            \begin{figure}[ht]
                \includegraphics[width=\textwidth]{InputFlow.jpg}
                \caption{Order of Input processing}
            \end{figure}

        \input{EIS/EIS.tex}


    \chapter{Save Game}
        \href{https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/SaveGame/}{Official DOCs}
        \begin{itemize}
            \item there is an existing SaveGame class
            \item global information and game session information can be saved in 2 seperate SaveGame classes
            \item Saving: the information is transfered from the current game world into a SaveGame object
            \item Loading: the information inside the SaveGame object is transfered to the world object like Characters, Player Controller ...
            \item 
        \end{itemize}
        \underline{Basic Steps:}
        \begin{itemize}
            \item create Blueprint Class with SaveGame as parent
            \item add variables for any information you need to save
            \item 
        \end{itemize}
        \underline{Used Nodes:}
        \begin{itemize}
            \item Create Save Game Object
            \item Async Save Game to Slot
        \end{itemize}

        \section{Using JSON}
            \begin{itemize}
                \item 
            \end{itemize}

        \section{Using c++}
            \begin{itemize}
                \item we need a \code{FArchive&} := holds also additional information:
                \begin{itemize}
                    \item \code{UsingCustomVersion}
                    \item \code{IsSaveGame}
                    \item \code{IsLoading}
                    \item \code{IsSaving}
                    \item ...
                \end{itemize}
                \item a \code{FObjectAndNameAsStringProxyArchive} is used to serialize pointers
                \item we set \code{FObjectAndNameAsStringProxyArchive::ArIsSaveGame} = \code{true} $\rightarrow$ only SaveGame uprops get saved
                \item 
                \item Advanced:
                \item we can use a Structured Archive that uses:
                \begin{itemize}
                    \item ArchiveFormatter (FBinaryArchiveFromatter, )
                    \item a \code{FStructuredArchive}
                \end{itemize}
                \item
                \item a structuredArchiveConsists of
                \begin{itemize}
                    \item Records: a container for named slots
                    \item Slots: storage location for values (literals or containers)
                    \item Containers:
                    \begin{itemize}
                        \item Array: contains fixed number of unnamed child slots
                        \item Stream: like an array, but unbound size
                        \item Map: contains a fixed number  of \textbf{named} child slots
                    \end{itemize}
                \end{itemize}
            \end{itemize}


\smallskip

    \chapter{LOD}
        \begin{itemize}
            \item LOD groups can be specified in a INI file \code{BaseEngine.ini} under \code{StaticMeshLODSettings}
            \item is a mesh based setting
            \item 
        \end{itemize}

        \underline{Colorcoding for LODs}
        \begin{itemize}
            \item 0 = White
            \item 1 = Red
            \item 2 = Green
            \item 3/Remaining = Blue
        \end{itemize}

        \underline{change LOD distance}
        \begin{itemize}
            \item screen size will trigger a LOD change
            \item ENABLE SCREEN SIZE: disable auto compute lod distance under 'LOD Settings'
            \item REMOVE LOD: inside of the LOD group the last entry is 'Remove LOD'
            \item 
        \end{itemize}
    
    \chapter{Level Design}
        \section{Basic Workflow}    
            \begin{itemize}
                \item Primitives
                \item replace primitives with blockouts, still simple lights
                \item Post Process, Lights, 
                \item Reflections, Effects, Volumes, Audio
            \end{itemize}

        \section{Levels}
            \subsection{Level Streaming (linear map loading)}
                \begin{itemize}
                    \item Level Streaming Volumes
                    \item Scripted Level Streaming
                    \item 
                \end{itemize}

                Load Level Instance:

            \underline{Useful commands}
            \begin{table}[!htb]
                \begin{tabular}{|l|l|}
                    \hline
                        Command & Description \\
                    \hline
                        stat levels & shows the level states \\
                    \hline
                \end{tabular}
            \caption{ caption }
            \end{table}

            

            \subsection{World Partition (open world map loading)}
                \begin{itemize}
                    \item replaces the old World Composition
                    \item World-Partition holds the Data-Layers
                    \item Data-Layers hold Actors
                    \item Actors can be assigned to any Layer (also multiple); is stored inside the Actor under \code{Layers}-category
                    
                \end{itemize}
                \chapter{Textures}
                \section{Texture Streaming}
                    \begin{itemize}
                        \item also called streamer
                        \item responsible for increasing and decreasing resolution of each texture
                    \end{itemize}
        \smallskip
                    Update Cycle
                    \begin{itemize}
                        \item update world view
                        \item choose optimal resolution for each texture
                        \item determine possible resolution depending on the pool size (RAM)
                        \item choose which textures to update
                        \item generate load/unload request
                    \end{itemize}
        \smallskip
                    Order in which the streamer will dropp the mips textures
                    \begin{itemize}
                        \item keep landscape texture, forced load textures and textures already missing resolutions
                        \item keep mips that are visible on screen
                        \item keep character textures and tesxtures that don't take much memory
                        \item drop mips that are not visible, dropping the last recently seen first
                    \end{itemize}
        \smallskip
                    Which textures should updated first
                    \begin{itemize}
                        \item Load visible mips
                        \item load forced load textures, landscape and character textures
                        \item load textures which are far from their target resolution first
                        \item load most recently seen first (not visible)
                    \end{itemize}
        \bigskip
                    After all that a batch of update requests is generated            
        
                
\input{Materials/Materials}
\input{Niagra/Niagra}
\input{WorldCreation/WorldCreation.tex}    
\input{UI/UI.tex}
    
\input{Light/Lights}
   
    \chapter{Collision}
        \href{https://www.unrealengine.com/en-US/blog/collision-filtering}{extensive blog entry}
        \uline{Keywords for collision:}
        \begin{itemize}
            \item \glsdesc{Collision Response (ECR)}
            \item 
        \end{itemize}

        You can define how objects should react to traces or how
        traces should react to object types.

        UE4 has a few ‘built in’ Trace Channels
        (Visibility, Camera) and Object Channels (WorldStatic, WorldDynamic, Pawn, PhysicsBody, Vehicle, Destructible),
        but you can easily add your own under Edit $\rightarrow$ Project Settings $\rightarrow$ Collision $\rightarrow$ 'Collision-Preset' to custom
        though you are limited to 32 in total. \\
        If both actors/components have the 'overlap' property they will go through each other.
        If only one has it, physix will be applied \\

        When two objects intersect, we look at how they respond to each other, and take the least blocking interaction
         \includegraphics[width=\textwidth]{CollisionExample.jpg}
        \underline{Object Types}
        \begin{table}[H]
            \begin{tabular}{|l|l|}
                \hline
                    Property & Description \\
                \hline
                    World Static & Actors that doesn't move. \\
                    World Dynamic & Actors that will move because of animation and code \\
                    Pawn & \\
                    PhysicsBody & \\
                    Vehicle & Vehicles reveice this type by default \\
                    Destructible & Destructible Meshes \\
                \hline
            \end{tabular}
        \end{table}
        
        \includegraphics[width=\textwidth]{Collision-Properties.png} \\

        \section{Create Custom-Collision-Box for modelled objects}
            \begin{itemize}
                \item Create Mesh
                \item Create Additional mesh with following Prefix
            \end{itemize}
            \begin{table}[H]
                \begin{tabular}{|l|l|}
                    \hline
                    Mesh Prefix and Name & Description \\
                    \hline
                    UBX\_[RenderMeshName]\_\#\# & Boxes are created with the Box objects. Don't move or deform \\
                    UCP\_[RenderMeshName]\_\#\# & Capsule (8 segements are good) \\
                    USP\_[RenderMeshName]\_\#\# & Spehere (8 segements) \\
                    UCX\_[RenderMeshName]\_\#\# & Convex shapes only (inner angles less then 180 degree) \\
                    \hline
                \end{tabular}
            \end{table}
            

        
\input{GAS/GAS.tex}

    \chapter{Physics Actor}
        \begin{itemize}
            \item First actor you have to select is the anker
            \item Second actor is the object you want to attach
        \end{itemize}

\input{Data/Data.tex}

\input{ECS/ECS.tex}

\input{AI/AI.tex}

\input{Animations/Animations.tex}

\input{BP/Blueprints}

\input{CPP/CPP}

\input{Networking/Networking.tex}

    \chapter{Modular Character}

            \section{Comparison of different ways}
                 \includegraphics[width=\textwidth]{ModularCharacterComparison.jpg}

            \section{Master Pose Component}
                The core is the 'Master Pose Component', enabling to set 'Skinned Mesh Component Object' as children
                to another 'Skinned Mesh Component' that is considered to be the master \\
                Children do not use any Bone Transform Buffer and don't run any animations \\
\smallskip \\
                This setup will be done in the construction script of a BP \\
                \includegraphics[width=\textwidth]{ConstructionScript.jpg} \\
                Children of the Master Bone has to be a subset with exact matching structure. \\
                No extra joints or skip any joints. Since there are no Bone Buffer data for extra joints,
                it will render using the reference pose. \\
                Cannot run any other animations or physics on any children. \\


                \underline{Components needed} (thirdpersoncharacter)
                \begin{itemize}
                    \item CapsuleComponent
                    \item ArrowComponent
                    \item SpringArmComponent
                    \item Camera
                \end{itemize}
\smallskip            
                And then you need a 'Skeletal Mesh' for every clothing part:
                \begin{itemize}
                    \item Hat
                    \item Upper Body (seperate underwear and shirt)
                    \item Arms
                    \item Hands
                    \item Lower Body (Seperate underwear and pants)
                    \item Feet
                \end{itemize}
\smallskip 
                \begin{itemize}
                    \item Copy Location/Rotation from torso to rest
                    \item Assign same BP for the clothings
                    \item 'Copy Pose From Mesh' is an AnimGraph node used on the Animation Blueprint of the child (only matching bones everything else will use reference pose (from parent))
                \end{itemize}
\smallskip
                Note: Copy Pose From Mesh is more expensive than Master Pose Component because this runs the animation on each child \\
                Additionally, if you want to use physics on the child, you may want to use the Rigid Body  or AnimDynamics  skeletal control nodes instead \\
                \includegraphics[width=\textwidth]{CopyPoseFromMesh.jpg} \\
\smallskip \\
                While PREVIEWING in the animation editor additional assigned meshed will automatically use copy pose from mesh \\
                OR use a CUSTOM PREVIEW MESH COLLECTION \\
\smallskip\\
                MERGE multiple Skeletal Meshes at runtime into a single Skeletal Mesh through code with FSKELETALMESHMERGE. \\
                High INITIAL cost of creating the Skeletal Mesh, the rendering cost is cheaper renderinga a single Skeletal Mesh instead of multiple meshes. \\
                For example character comprised of three Components (head, body and legs).  50 characters on screen $\rightarrow$ 50 draw calls. \\
                Without Skeletal Mesh Merge: each Component own draw call + three calls per character $\rightarrow$ 150 draw calls.  \\
\smallskip \\
                When using FSKELETALMESHMERGE the Master Pose Component (body) has to contain all the animations \\
                If extra joints for certain body parts, still need all animations on the body. \\
                Can only run one animation on the merged mesh and transferring Morph Targets to the merged mesh is not supported. \\
                With a mergedMesh $\rightarrow$ FSkeletalMeshMerge::GenerateLODModel create your Morph Targets by calculating the FMorphTargetDelta between your base mesh and any morphs. \\
\smallskip \\
                FSkeletalMeshMerge build your content in a specific way from the start.
                use one common Material and decide on an atlas for your Textures (for example, boots go in this region while gloves go in this region and so on)
                so you can cut up and put together your textures to make new ones and render your whole character as one section \\

\smallskip

\input{PixelStreaming/PixelStreaming.tex}

\input{Optimization/Optimization.tex}

\input{GameplayMechanics/GameplayMechanics.tex}
            

    \chapter{Cooking \& Packaging}
        \begin{itemize}
            \item is the process of: converting internal format to the platform specific format
            \item assets are stored in a custom format inside unreal
        \end{itemize}

    \chapter{Debugging}


        \section{Basic methods}
            \begin{itemize}
                \item Print string and an additional Macro with variables (ex. bPrintDebugMessages)
                \item \hyperref[sec:visuallogger]{visual logger} (ex. heatmaps showing )
                \item console commands
                \item execute console commands from BP (for example UI to toggle things)
                \item get platform name
            \end{itemize}
        

        \section{Output Log}
            \begin{itemize}
                \item tells what is going on in UE4
                \item 
            \end{itemize}


    \chapter{Console Commands}
        In order to open cmd hit \^ \\
        \underline{Show collision boxes}
        \begin{lstlisting}
        show Collision
        \end{lstlisting}
        \begin{table}[H]
            \begin{tabular}{|l|c|}
                \hline
                    Command & Description \\
                \hline
                    [COMMAND] ? & help for the command \\
                    stat scenerendering & diplsays rendering counts \\
                    stat memory & shows the memory usage \\
                    stat none & remove all stat info \\
                    stat unitgraph & graph gpu usage \\
                    obj list class=skeletalmesh & will display all objects of a type in memory \\
                    show Collision & shows the collision boxes for meshes \\
                    r. & are rendering commands \\
                    r.SkyAtmosphere.Visualize 1 & turn on the Visualization for debugging \\
                    r.VT.Borders 1 & shows which textures are virtual textures \\
                    ShowDebug Bones & will show the Skeletal Mesh Bones \\
                    ShowDebug Animation & will show information about the animation states ... \\
                    
                \hline
            \end{tabular}
        \end{table}
\smallskip

    \chapter{Create Custom Template}
        \href{https://www.youtube.com/watch?time_continue=119&v=MYM7iSh-uac&feature=emb_logo}{YT-Video} explaining the process \\
        \begin{itemize}
            \item Create new project
            \item setup everything you want to be in the template
            \item regenerate project id: Project Settings $\rightarrow$ Description $\rightarrow$ Project ID
            \item Copy:
            \begin{itemize}
                \item Config
                \item Content
                \item Source
                \item Saved
                \item *.uproject
            \end{itemize}
            \item from the 'ProjectFolder' to 'Engine/Templates/...'
            \item 
            \item Create a 'Media'-Folder and place an image there
            \item Copy the 'TempalteDefs.ini' from an existing template
        \end{itemize}


\input{Plugins/Plugins.tex}

\input{ToolsDev/ToolsDev.tex}

\smallskip            
\smallskip
\newpage
\include{Cheatsheet_CPP/Cheatsheet_CPP.tex}



    \chapter{Additional}
        \section{Add sockets to static meshes inside blender}
         \includegraphics[width=\textwidth]{AddSocketOnMesh.jpeg}



\newpage
    \glsaddall
    \printglossary[title=Glossar, toctitle=Glossar]
    \printglossaries      

\end{document}